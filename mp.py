# -*- coding: utf-8 -*-
"""Copy of ML_MP.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-00K3W_Qy_QM9kuvqzAQmIGzJ5e_aQJO
"""

import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
from sklearn.model_selection import train_test_split,GridSearchCV
from sklearn.preprocessing import OneHotEncoder,MinMaxScaler,StandardScaler,LabelEncoder
from sklearn.compose import ColumnTransformer,make_column_selector
from sklearn.metrics import classification_report,roc_auc_score,ConfusionMatrixDisplay,f1_score,accuracy_score
from sklearn.exceptions import NotFittedError
import tensorflow as tf
sns.set_style('darkgrid')
from sklearn.model_selection import (train_test_split,KFold,RandomizedSearchCV)
from scipy.stats import (randint,uniform)
from xgboost import XGBClassifier
from sklearn.metrics import (accuracy_score,confusion_matrix,classification_report)

df = pd.read_csv("./waterQuality.csv")

df.head()

df.isnull().sum()

df.info()

df.describe()

target = 'is_safe'

df.loc[[7551, 7568,7890],'ammonia']

df.loc[[7551, 7568,7890],'is_safe']

df.drop([7551,7568,7890],axis=0,inplace=True)

df['ammonia']=df['ammonia'].astype('float64')
df['is_safe']=df['is_safe'].astype('int64')

num_col=[]
for col in df.select_dtypes(exclude='object'):
    if(col!=target):
        print(f"{col:30} ----> {df[col].nunique():10} unique values")
        num_col.append(col)

df.info()

plt.figure(figsize=(20,10))
sns.heatmap(df.corr(), annot=True)
plt.show()

new_df = df[['perchlorate','chloramine','chromium','silver','barium']]

sns.pairplot(new_df)

plt.figure(figsize=(30,20))
j=1
for i,columns in enumerate(num_col):
    plt.subplot(5,4,j)
    sns.histplot(x=columns,data=df,kde=True,hue=target)
    j+=1
plt.tight_layout()

r=3
c=7
it=1
for i in df.columns:
    plt.subplot(r,c,it)
    sns.barplot(y=df.loc[:,i],x='is_safe',data=df)
    plt.title(i)
    it+=1
plt.tight_layout()
plt.show()

oh=OneHotEncoder(drop='first',handle_unknown='ignore')

ms,ss=MinMaxScaler(),StandardScaler()

ct=ColumnTransformer([
    ('num_encoder',ss,make_column_selector(dtype_include='float64'))
],remainder='passthrough',verbose=True)

X=df.drop([target],axis=1)
y=df[[target]]
X.head(1)

y.head(1)

X_train,X_test,y_train,y_test=train_test_split(X,y,test_size=0.20,stratify=y,random_state=42)

X_train.shape,y_train.shape

X_test.shape,y_test.shape

X_test.head(2)

y_test.head(2)

X_train, X_test, y_train, y_test = train_test_split(df.drop('is_safe', axis = 1),
                                                    df['is_safe'],
                                                    test_size = 0.2,
                                                    random_state = 0)

model = XGBClassifier()

param_grid = {
    'n_estimators': randint(50, 251),
    'max_depth': randint(3, 15),
    'min_child_weight': randint(1, 11),
    'gamma': uniform(0.0, 1.0),
}

kf = KFold(n_splits = 5, shuffle = True, random_state = 0)

search = RandomizedSearchCV(model,
                            param_grid,
                            scoring = 'accuracy',
                            cv = kf,
                            n_iter = 100,
                            refit = True,
                            n_jobs = -1)

search.fit(X_train, y_train)

search.best_params_

search.best_score_

print(f'Train Score : {accuracy_score(y_train, search.predict(X_train))}')
print(f'Test Score : {accuracy_score(y_test, search.predict(X_test))}')

confusion_matrix(y_test, search.predict(X_test))

print(classification_report(y_test, search.predict(X_test)))
